#version 430

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba32f) uniform image2D screen;

uniform vec3 camera_pos;
uniform vec3 camera_dir;
uniform vec3 light_dir;
uniform float fov;
uniform int SIZE;

struct IVec3 {
    int x;
    int y;
    int z;
};

struct RayHit {
    //OctreeNode node;
    // if t == -1 no hit
    ivec3 voxel_pos;
    ivec3 dir;
    float dist;
    int steps;
};

//const int SIZE = 128;
const vec3 POS = vec3(0,0,0);
const float MAX_DIST = 1500.;

layout(std430, binding = 0) buffer ChunkDataBuffer {
    bool data[];
};

bool getData(ivec3 voxel_pos) {
    if (voxel_pos.x < 0 || voxel_pos.x >= SIZE ||
        voxel_pos.y < 0 || voxel_pos.y >= SIZE ||
        voxel_pos.z < 0 || voxel_pos.z >= SIZE )
    {
        return false;
    } else {
        return data[voxel_pos.x *SIZE*SIZE + voxel_pos.y * SIZE + voxel_pos.z ];
    }
}

struct Voxel {
    int data;
};

struct Brick {
    Voxel data[8][8][8];
};

layout(std430, binding = 1) buffer DebugBuffer {
    float debugNums[];
};

layout(std430, binding = 2) buffer BrickGridBuffer {
    uint brickGrid[];
};
layout(std430, binding = 3) buffer BrickDataBuffer {
    Brick brickData[];
};

uint index_brick_grid(ivec3 voxel_pos) {
    if (voxel_pos.x < 0 || voxel_pos.x >= SIZE/8 ||
        voxel_pos.y < 0 || voxel_pos.y >= SIZE/8 ||
        voxel_pos.z < 0 || voxel_pos.z >= SIZE/8 )
    {
        return 696969; 
    } else {
        return brickGrid[voxel_pos.x *SIZE/8*SIZE/8 + voxel_pos.y * SIZE/8 + voxel_pos.z ];
    }
}

//bool getVoxel(ivec3 pos) {
    //if (pos.x < 0 || pos.x >= SIZE ||
        //pos.y < 0 || pos.y >= SIZE ||
        //pos.z < 0 || pos.z >= SIZE )
    //{
        //return false; 
    //} 
    //ivec3 grid_coords = pos / 8;
    //ivec3 brick_coords = pos % 8;
//
    //uint brick_index = brickGrid[pos.x *SIZE/8*SIZE/8 + pos.y * SIZE/8 + pos.z ];
//
    //Brick brick = brickData[brick_index];
//
    //Voxel voxel_pos = brick.data[brick_coords.x][brick_coords.y][brick_coords.z];
//
    //return bool(voxel_pos.data);
//}

bool getVoxel(ivec3 pos) {
    if (pos.x < 0 || pos.x >= SIZE ||
        pos.y < 0 || pos.y >= SIZE ||
        pos.z < 0 || pos.z >= SIZE )
    {
        return false; 
    } 
    //ivec3 grid_coords = pos / 8;
    //ivec3 brick_coords = pos % 8;
    //Brick brick = brickData[brickGrid[grid_coords.x * SIZE/8*SIZE/8 + grid_coords.y * SIZE/8 + grid_coords.z ]];
    //Voxel voxel_pos = brick.data[brick_coords.x][brick_coords.y][brick_coords.z];

    Brick brick = brickData[0];
    Voxel voxel_pos = brick.data[pos.x][pos.y][pos.z];


    return bool(voxel_pos.data);
}

RayHit dda_3d(vec3 ray_start, vec3 dir);
float ray_aabb_cube(vec3 ray_start, vec3 dir, vec3 min_pos, vec3 max_pos);

uniform uint test_uint;

void main() {
    //debugNums[0] = float(brickGrid[1]);
    ivec3 voxel_pos = ivec3(19,19,19);
    debugNums[0] = float(index_brick_grid(voxel_pos));

    // Get the coordinates of the pixel to write
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    vec2 res = vec2(imageSize(screen));

	vec2 ndc = (vec2(pixel_coords) * 2 - res) / res;
    ndc.x *= res.x / res.y;

    vec3 forward = camera_dir;
    vec3 left   = normalize(cross(forward, vec3(0.,1.,0.)));
    vec3 up     = cross(left,forward);

    float scale = tan(radians(fov * 0.5));
    vec3 ray_dir = normalize(forward - (ndc.x * scale * left) + (ndc.y * scale * up));

    vec3  pixel = vec3(0.2, 0.3, 0.3);

    RayHit ray_hit = dda_3d(camera_pos,ray_dir);

    // SHADING
    if (ray_hit.dist > 0.) {
        vec3 hit = camera_pos + ray_dir * ray_hit.dist;

        vec3 hit_dir = vec3(ray_hit.dir);

        float ambient = 0.05;
        float dot_light = dot(light_dir,hit_dir);
        float ratio = (dot_light + 1.0) / 2.0;
        pixel = (vec3(0,0,1) * ratio) + ambient;
    }


    // exeeded the numer of steps
    if (ray_hit.dist == -1) {
        //pixel = vec3(1,0,0);
        //pixel = vec3(float(ray_hit.steps)/300.,0,0);
        //pixel = vec3((100-float(ray_hit.steps))/100.,0,float(ray_hit.steps)/300.);
    } else {
        //pixel = vec3(0,0,float(ray_hit.steps)/300.);
    }


    // aabb not hit
    if (ray_hit.dist == -2) {
        //pixel = vec3(0,1,0);
        //pixel = vec3(0.2, 0.3, 0.3);
    }


    imageStore(screen, pixel_coords, vec4(pixel,1.0));
}

vec3 step_mask(vec3 dist) {
    // From https://www.shadertoy.com/view/l33XWf
    bvec3 move;
    bvec3 pon = lessThan(dist.xyz,dist.yzx);

    move.x = pon.x && !pon.z;
    move.y = pon.y && !pon.x;
    move.z = !(move.x||move.y);

    return vec3(move);
}

float mask_vec3(vec3 v, vec3 mask) {
    vec3 tmp = mask * v;
    return max(tmp.x, max(tmp.y,tmp.z));
}

RayHit dda_3d(vec3 ray_start, vec3 dir){

    // AABB CUBE CLIP BEGIN

    vec3 inv_dir = 1.0 / dir;

    // Initialize t_min and t_max
    vec3 t0 = (POS - ray_start) * inv_dir;
    vec3 t1 = (POS + SIZE - ray_start) * inv_dir;

    // Reorder t_min and t_max for each axis
    vec3 t_min = min(t0, t1);
    vec3 t_max = max(t0, t1);

    float t_enter = max(max(t_min.x, t_min.y), t_min.z);
    float t_exit  = min(min(t_max.x, t_max.y), t_max.z);

    // Check for intersection
    if (!(t_enter <= t_exit && t_exit >= 0.0)) {
        RayHit hit_out;
        hit_out.dist = -2.;
        return hit_out;
    }
    if (t_enter > 0.) {
        ray_start = ray_start + dir * (t_enter - 0.001);
    } 
    // AABB CUBE CLIP END

    ivec3 voxel_pos = ivec3(floor(ray_start));
    ivec3 step_dir  = ivec3(sign(dir));
    vec3 t_delta = 1.0 / dir;

    vec3 axis_dist = ((voxel_pos - ray_start) + 0.5 + step_dir * 0.5) * 1./dir;

    // 0 => X;
    // 1 => Y;
    // 2 => Z;
    int last_dir = -1;
    int steps = 0;
    float max_distance = t_exit - t_enter;
    float traveled_distance = 0.0;
    vec3 mask = step_mask(axis_dist);
    while (traveled_distance < max_distance) {
        if (getData(voxel_pos)) {
            //return Some((voxel_pos,ray_start + dir * traveled_distance));
            ivec3 hit_dir = ivec3(mask*step_dir);
            return RayHit(voxel_pos, hit_dir,traveled_distance, steps);
        }

        mask    = step_mask(axis_dist);
        voxel_pos += ivec3(mask * step_dir);
        traveled_distance = mask_vec3(axis_dist, mask);
        axis_dist += mask * step_dir * t_delta;

        steps++;
    }
    RayHit hit;
    hit.dist = -1.;
    hit.steps = steps;
    return hit;
}
