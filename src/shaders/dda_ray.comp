#version 430

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba32f) uniform image2D screen;

uniform vec3 camera_pos;
uniform vec3 camera_dir;
uniform vec3 light_dir;
uniform float fov;
uniform int SIZE;

struct IVec3 {
    int x;
    int y;
    int z;
};

struct RayHit {
    //OctreeNode node;
    // if t == -1 no hit
    ivec3 voxel;
    ivec3 dir;
    float dist;
    int steps;
};

//const int SIZE = 128;
const vec3 POS = vec3(0,0,0);
const float MAX_DIST = 1500.;

layout(std430, binding = 0) buffer OctreeBuffer {
    bool data[];
};
bool getData(ivec3 voxel) {
    if (voxel.x < 0 || voxel.x >= SIZE ||
        voxel.y < 0 || voxel.y >= SIZE ||
        voxel.z < 0 || voxel.z >= SIZE )
    {
        return false;
    } else {
        return data[voxel.x + voxel.y * SIZE + voxel.z * SIZE*SIZE];
    }
}

layout(std430, binding = 1) buffer DebugBuffer {
    float debugNums[];
};

RayHit dda_3d(vec3 start, vec3 dir, float max_distance);
float ray_aabb_cube(vec3 start, vec3 dir, vec3 min_pos, vec3 max_pos);

void main() {
    // Get the coordinates of the pixel to write
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    vec2 res = vec2(imageSize(screen));

	vec2 ndc = (vec2(pixel_coords) * 2 - res) / res;
    ndc.x *= res.x / res.y;

    vec3 forward = camera_dir;
    vec3 left   = normalize(cross(forward, vec3(0.,1.,0.)));
    vec3 up     = cross(left,forward);

    float scale = tan(radians(fov * 0.5));
    vec3 ray_dir = normalize(forward - (ndc.x * scale * left) + (ndc.y * scale * up));

    vec3  pixel = vec3(0.2, 0.3, 0.3);

    RayHit ray_hit = dda_3d(camera_pos,ray_dir,MAX_DIST);

    // SHADING
    if (ray_hit.dist > 0.) {
        vec3 hit = camera_pos + ray_dir * ray_hit.dist;

        vec3 hit_dir = vec3(ray_hit.dir);

        float ambient = 0.05;
        float dot_light = dot(light_dir,hit_dir);
        float ratio = (dot_light + 1.0) / 2.0;
        pixel = (vec3(0,0,1) * ratio) + ambient;
    }


    // exeeded the numer of steps
    if (ray_hit.dist == -1) {
        //pixel = vec3(1,0,0);
        pixel = vec3(float(ray_hit.steps)/300.,0,0);
        //pixel = vec3((100-float(ray_hit.steps))/100.,0,float(ray_hit.steps)/300.);
    } else {
        pixel = vec3(0,0,float(ray_hit.steps)/300.);
    }


    // aabb not hit
    if (ray_hit.dist == -2) {
        //pixel = vec3(0,1,0);
        pixel = vec3(0.2, 0.3, 0.3);
    }


    imageStore(screen, pixel_coords, vec4(pixel,1.0));
}

float frac0(float x) {
    return x - floor(x);
}
float frac1(float x) {
    return 1.0 - x + floor(x);
}

RayHit dda_3d(vec3 start, vec3 dir, float max_distance){

    // AABB CUBE BEGIN
    // Calculate the inverse of the direction
    vec3 inv_dir = 1.0 / dir;

    // Initialize t_min and t_max
    vec3 t_min = (POS - start) * inv_dir;
    vec3 t_max = (POS+SIZE - start) * inv_dir;

    // Reorder t_min and t_max for each axis
    if (inv_dir.x < 0.0) {
        float temp = t_min.x;
        t_min.x = t_max.x;
        t_max.x = temp;
    }
    if (inv_dir.y < 0.0) {
        float temp = t_min.y;
        t_min.y = t_max.y;
        t_max.y = temp;
    }
    if (inv_dir.z < 0.0) {
        float temp = t_min.z;
        t_min.z = t_max.z;
        t_max.z = temp;
    }

    // Calculate t_enter and t_exit
    float t_enter = max(max(t_min.x, t_min.y), t_min.z);
    float t_exit = min(min(t_max.x, t_max.y), t_max.z);

    float max_dist;
    // Check for intersection
    if (t_enter <= t_exit && t_exit >= 0.0) {
        max_dist = t_exit;
    } else {
        RayHit hit_out;
        hit_out.dist = -2.;
        return hit_out;
    }

    // AABB CUBE END

    float t_max_x;
    float t_max_y;
    float t_max_z;
    if (t_enter < 0.) {
        t_max_x = 0.;
        t_max_y = 0.;
        t_max_z = 0.;
    } else {
        start = start + dir * (t_enter - 1.);
        t_max_x = t_enter -1.;
        t_max_y = t_enter -1.;
        t_max_z = t_enter -1.;
    } 

    ivec3 voxel     = ivec3(floor(start));
    ivec3 step_dir  = ivec3(sign(dir));
    vec3 t_delta = 1.0 / abs(dir);

    max_distance = max_dist;

    if (dir.x > 0.) {
        t_max_x += t_delta.x * frac1(start.x);
    } else {
        t_max_x += t_delta.x * frac0(start.x);
    };
    if (dir.y > 0.) {
        t_max_y += t_delta.y * frac1(start.y);
    } else {
        t_max_y += t_delta.y * frac0(start.y);
    };
    if (dir.z > 0.) {
        t_max_z += t_delta.z * frac1(start.z);
    } else {
        t_max_z += t_delta.z * frac0(start.z);
    };


    // 0 => X;
    // 1 => Y;
    // 2 => Z;
    int last_dir = -1;
    int steps = 0;
    float traveled_distance = 0.0;
    while (traveled_distance < max_distance) {
        if (getData(voxel)) {
            //return Some((voxel,start + dir * traveled_distance));
            ivec3 hit_dir;
            switch (last_dir) {
                case 0: hit_dir = ivec3(1,0,0) * step_dir.x;
                        break;
                case 1: hit_dir = ivec3(0,1,0) * step_dir.y;
                        break;
                case 2: hit_dir = ivec3(0,0,1) * step_dir.z;
                        break;
            }
            return RayHit(voxel,hit_dir,traveled_distance,steps);
        }

        if (t_max_x < t_max_y) {
            if (t_max_x < t_max_z) {
                voxel.x += step_dir.x;
                traveled_distance = t_max_x;
                t_max_x += t_delta.x;
                last_dir = 0;
            } else {
                voxel.z += step_dir.z;
                traveled_distance = t_max_z;
                t_max_z += t_delta.z;
                last_dir = 2;
            }
        } else {
            if (t_max_y < t_max_z) {
                voxel.y += step_dir.y;
                traveled_distance = t_max_y;
                t_max_y += t_delta.y;
                last_dir = 1;
            } else {
                voxel.z += step_dir.z;
                traveled_distance = t_max_z;
                t_max_z += t_delta.z;
                last_dir = 2;
            }
        }
        steps++;
    }
    RayHit hit;
    hit.dist = -1.;
    hit.steps = steps;
    return hit;
}
